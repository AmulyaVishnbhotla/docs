---
---

= Resize

== tl;dr

Implement a program that enlarges BMPs, per the below.

[source,subs=quotes]
----
$ [underline]#./resize small.bmp large.bmp#
----

== Background

Be sure you're familiar with the structure of 24-bit uncompressed BMPs, as introduced in link:../../whodunit/whodunit[Whodunit].

== Distribution

=== Downloading

[source]
----
$ wget https://github.com/cs50/problems/archive/resize.zip
$ unzip resize.zip
$ rm resize.zip
$ mv problems-resize resize
$ cd resize
$ ls
TODO
----

== Specification

Implement a program called `resize` that enlarges 24-bit uncompressed BMPs by a factor of `n`.

* Implement your program in a file called `resize.c` in a directory called `resize`.
* Your program should accept exactly three command-line arguments, whereby
+
--
** the first (`n`) must be a positive integer less than or equal to `100`,
** the second must be the name of a BMP to be resized, and
** the third must be the name of the resized version to be written.
--
+ If it is not, it should remind the user of correct usage, as with `fprintf`, and `main` should return `1`.
* Your program, if it uses `malloc`, must not leak any memory.

== Walkthrough

video::e7WtAQDk904[youtube]

== Usage

Your program should behave per the examples below. Assumed that the underlined text is what some user has typed.

[source,subs=quotes]
----
$ [underline]#./resize#
Usage: ./resize n infile outfile
$ echo $?
1
----

[source,subs=quotes]
----
$ [underline]#./resize 2 small.bmp larger.bmp#
$ echo $?
0
----

== Hints

With a program like this, we could have created `large.bmp` out of `small.bmp` by resizing the latter by a factor of 4 (i.e., by multiplying both its width and its height by 4), per the below. 

[source]
----
./resize 4 small.bmp large.bmp
----

You're welcome to get started by copying (yet again) `copy.c` and naming the copy `resize.c`. But spend some time thinking about what it means to resize a BMP. (You may assume that `n` times the size of `infile` will not exceed 2^32^ - 1.) Decide which of the fields in `BITMAPFILEHEADER` and `BITMAPINFOHEADER` you might need to modify. Consider whether or not you'll need to add or subtract padding to scanlines. And do be sure to support a value of `1` for `n`, the result of which should be an `outfile` with dimensions identical to ``infile``'s.

If you happen to use `malloc`, be sure to use `free` so as not to leak memory. Try using `valgrind` to check for any leaks!

== Testing

If you'd like to peek at, e.g., ``large.bmp``'s headers (in a more user-friendly way than `xxd` allows), you may execute the below.

[source]
----
~cs50/pset4/peek large.bmp
----

Better yet, if you'd like to compare your outfile's headers against those from the <<staffs-solution,staff's solution>>, you might want to execute commands like the below while inside your `~/workspace/pset4/bmp` directory. (Think about what each is doing.)

[source]
----
./resize 4 small.bmp student.bmp
~cs50/pset4/resize 4 small.bmp staff.bmp
~cs50/pset4/peek student.bmp staff.bmp
----

=== `check50`

[source]
----
check50 2016.resize.less bmp.h resize.c
----

== Staff's Solution

[source]
----
~cs50/pset4/resize
----

== recover

Alright, now let's put all your new skills to the test.

In anticipation of this problem set, I spent the past several days snapping photos of people I know, all of which were saved by my digital camera as JPEGs on a 1GB CompactFlash (CF) card. (It's possible I actually spent the past several days on Facebook instead.) Unfortunately, I'm not very good with computers, and I somehow deleted them all! Thankfully, in the computer world, "deleted" tends not to mean "deleted" so much as "forgotten." My computer insists that the CF card is now blank, but I'm pretty sure it's lying to me.

Write in `~/workspace/pset4/jpg/recover.c` a program that recovers these photos.

Ummm.

Okay, here's the thing. Even though JPEGs are more complicated than BMPs, JPEGs have "signatures," patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are 

[source]
----
0xff 0xd8 0xff
----

from first byte to third byte, left to right. The fourth byte, meanwhile, is either `0xe0`, `0xe1`, `0xe2`, `0xe3`, `0xe4`, `0xe5`, `0xe6`, `0xe7`, `0xe8`, `0xe8`, `0xe9`, `0xea`, `0xeb`, `0xec`, `0xed`, `0xee`, of `0xef`. Put another way, the fourth byte's first four bits are `1110`.

Odds are, if you find this pattern of four bytes on a disk known to store photos (e.g., my CF card), they demark the start of a JPEG. (To be sure, you might encounter these patterns on some disk purely by chance, so data recovery isn't an exact science.)

Fortunately, digital cameras tend to store photographs contiguously on CF cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras generally initialize CF cards with a FAT file system whose "block size" is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that's 1 MB (i.e., 1,048,576 B) thus takes up 1048576 รท 512 = 2048 "blocks" on a CF card. But so does a photo that's, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called "slack space." Forensic investigators often look at slack space for remnants of suspicious data.

The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my CF card, looking for JPEGs' signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my CF card, closing that file only once you encounter another signature. Moreover, rather than read my CF card's bytes one at a time, you can read 512 of them at a time into a buffer for efficiency's sake. Thanks to FAT, you can trust that JPEGs' signatures will be "block-aligned." That is, you need only look for those signatures in a block's first four bytes. 

Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this CF card was brand-new when I started snapping photos, odds are it'd been "zeroed" (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It's okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable.

Now, I only have one CF card, but there are a whole lot of you! And so I've gone ahead and created a "forensic image" of the card, storing its contents, byte after byte, in a file called `card.raw`. So that you don't waste time iterating over millions of 0s unnecessarily, I've only imaged the first few megabytes of the CF card. But you should ultimately find that the image contains 50 JPEGs. As usual, you can open the file programmatically with `fopen`, as in the below. 

[source,c]
----
FILE* file = fopen("card.raw", "r");
----

Notice, incidentally, that `~/workspace/pset4/jpg` contains only `recover.c`, but it's devoid of any code. (We leave it to you to decide how to implement and compile `recover`!) For simplicity, you should hard-code `"card.raw"` in your program; your program need not accept any command-line arguments. When executed, though, your program should recover every one of the JPEGs from `card.raw`, storing each as a separate file in your current working directory. Your program should number the files it outputs by naming each `pass:[###].jpg`, where `pass:[###]` is three-digit decimal number from `000` on up. (Befriend `sprintf`.) You need not try to recover the JPEGs' original names. To check whether the JPEGs your program spit out are correct, simply double-click and take a look! If each photo appears intact, your operation was likely a success!

Odds are, though, the JPEGs that the first draft of your code spits out won't be correct. (If you open them up and don't see anything, they're probably not correct!) Execute the command below to delete all JPEGs in your current working directory.

[source]
----
rm *.jpg
----

If you'd rather not be prompted to confirm each deletion, execute the command below instead.

[source]
----
rm -f *.jpg
----

Just be careful with that `-f` switch, as it "forces" deletion without prompting you.

If you'd like to check the correctness of your program with `check50`, you may execute the below.

[source]
----
check50 2015.fall.pset4.recover recover.c
----

Lest it spoil your (forensic) fun, the staff's solution to `recover` is not available.

As before, if you happen to use `malloc`, be sure to use `free` so as not to leak memory. Try using `valgrind` to check for any leaks!

Here's Zamyla!

video::Y4vV61lbL3g[youtube,height=540,width=960]

== Sanity Checks

Before you consider this problem set done, best to ask yourself these questions and then go back and improve your code as needed! Do not consider the below an exhaustive list of expectations, though, just some helpful reminders. The checkboxes that have come before these represent the exhaustive list! To be clear, consider the questions below rhetorical. No need to answer them in writing for us, since all of your answers should be "yes!"

* Did you fill `questions.txt` with answers to all questions?
* Is the BMP that `whodunit` outputs legible (to you)?
* Does `resize` accept three and only three command-line arguments?
* Does `resize` ensure that `n` is in [1, 100]?
* Does `resize` update `bfSize`, `biHeight`, `biSizeImage`, and `biWidth` correctly?
* Does `resize` add or remove padding as needed?
* Are you sure that `resize` doesn't have any memory leaks?
* Does `recover` output 50 JPEGs? Are all 50 viewable?
* Does `recover` name the JPEGs `pass:[###].jpg`, where `pass:[###]` is a three-digit number from `000` through `049`?
* Are you sure that `recover` doesn't have any memory leaks?
* Are all of your files where they should be in `~/workspace/pset4`?

As always, if you can't answer "yes" to one or more of the above because you're having some trouble, do drop by office hours or turn to https://cs50.net/discuss[CS50 Discuss]!

== Fabulous Prizes

And now the real fun begins. You are hereby challenged to find as many of the computer scientists featured in these photos as possible. To prove that you found someone, take a photo of yourself posing (anywhere) with the computer scientist (in such a way that he or she is aware of the photo and not just in the background). If a photo contains multiple computer scientists, you're welcome to pose with each of them separately. Upload your photos (i.e., the photos you took, not the ones that you
recovered) to a non-private album somewhere that supports bulk downloads (e.g., workspace, Imgur, etc.), then email your album's URL to selfies@cs50.net by *noon on Mon 10/19*! We'll add your photos to a public gallery (unless you request otherwise).

For each (hey, that's a loop) of the computer scientists you find, we'll set you up with 1GB of Dropbox space! In other words, if you snag _n_ selfies, we'll send you _n_ GB of Dropbox space (thanks to a former head TF who's now at Dropbox)! (Though supplies may be limited.)

Moreover, whoever finds and photographs the most computer scientists (and, in the event of a tie, submits first) shall be rewarded with a little something extra.
